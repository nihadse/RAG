final_path = "/mnt/final_DRC_cleaned.xlsx"
df.to_excel(final_path, index=False)
print(f"✅ Final file saved to: {final_path}")


import numpy as np

def is_probably_registre(text):
    if not isinstance(text, str):
        return False
    text = text.strip()
    # Count digits (Arabic or Latin)
    digit_count = sum(c.isdigit() for c in text)
    return digit_count >= 14

# Apply transformation
df["Registre de commerce (extracted)"] = df.apply(
    lambda row: row["N° d'inscription"] if is_probably_registre(row["N° d'inscription"]) else row.get("Registre de commerce", np.nan),
    axis=1
)

# Clean N° d'inscription if it was a RC
df["N° d'inscription"] = df.apply(
    lambda row: np.nan if is_probably_registre(row["N° d'inscription"]) else row["N° d'inscription"],
    axis=1
)

# Optional: Rename the new RC column
df["Registre de commerce"] = df["Registre de commerce (extracted)"]
df.drop(columns=["Registre de commerce (extracted)"], inplace=True)







Bonjour Imene,

Après réception des fichiers GESKYC transmis, nous constatons que le même problème persiste : un écart important est toujours présent par rapport aux mois précédents.

Le volume de fichiers transmis pour le mois de juin est nettement inférieur à celui du mois de mai.
Voici les détails constatés :

INTIER_PP_PM.csv
Mai 2025 : 370 201 lignes
Juin 2025 : 329 351 lignes

GESKYC_PP.csv
Mai 2025 : 357 599 lignes
Juin 2025 : 251 269 lignes


Merci de bien vouloir vérifier de votre côté.

Cordialement,
Nihad









import re

def fix_and_convert_registre(text):
    """
    Find and correct registration numbers that contain two digits + Arabic letter,
    and ensure they appear first. Then convert Arabic letter to Latin equivalent.
    """
    if not isinstance(text, str):
        return text

    text = text.strip()

    # Map Arabic letters to Latin equivalents
    arabic_to_latin = {
        "ا": "A", "أ": "A", "إ": "A",
        "ب": "B", "ت": "T", "ث": "TH", "ج": "J", "ح": "H", "خ": "KH",
        "د": "D", "ذ": "DH", "ر": "R", "ز": "Z",
        "س": "S", "ش": "CH", "ص": "S", "ض": "D", "ط": "T", "ظ": "Z",
        "ع": "A", "غ": "GH", "ف": "F", "ق": "Q", "ك": "K", "ل": "L",
        "م": "M", "ن": "N", "ه": "H", "و": "W", "ي": "Y"
    }

    # Match "19أ" (two digits + Arabic letter)
    match = re.search(r"(\d{2})([^\d\s])", text)
    if match:
        prefix = match.group(0)  # e.g., "19أ"
        rest = re.sub(re.escape(prefix), "", text).strip()  # Remove the prefix from original
        arabic_letter = match.group(2)
        latin = arabic_to_latin.get(arabic_letter, arabic_letter)
        fixed = match.group(1) + latin  # "19A"
        return f"{fixed} {rest}".strip()

    return text  # If no match, return original

df["Registre de commerce"] = df["Registre de commerce"].apply(fix_and_convert_registre)


output_path = "/mnt/DRC_final_fixed.xlsx"
df.to_excel(output_path, index=False)
print(f"✅ File saved with fixed Registre de commerce: {output_path}")











import re

def convert_arabic_to_latin(text):
    """
    Fix and convert Arabic letters in registration numbers to Latin equivalents.
    Ensures format is: two digits followed by a letter (e.g., '19أ' or 'أ19' -> '19A').
    """
    if not isinstance(text, str):
        return text

    arabic_to_latin = {
        "ا": "A", "أ": "A", "إ": "A",
        "ب": "B",
        "ت": "T", "ث": "TH", "ج": "J", "ح": "H", "خ": "KH",
        "د": "D", "ذ": "DH", "ر": "R", "ز": "Z",
        "س": "S", "ش": "CH", "ص": "S", "ض": "D", "ط": "T", "ظ": "Z",
        "ع": "A", "غ": "GH",
        "ف": "F", "ق": "Q", "ك": "K", "ل": "L", "م": "M", "ن": "N",
        "ه": "H", "و": "W", "ي": "Y",
    }

    # Remove whitespace
    text = text.strip()

    # Match formats like "أ19" or "19أ"
    match_arabic_first = re.match(r"^([^\d\s])(\d+)$", text)  # e.g., "أ19"
    match_digit_first = re.match(r"^(\d{2})([^\d\s])$", text)  # e.g., "19أ"

    if match_arabic_first:
        letter, digits = match_arabic_first.groups()
        latin = arabic_to_latin.get(letter, letter)
        return digits + latin

    elif match_digit_first:
        digits, letter = match_digit_first.groups()
        latin = arabic_to_latin.get(letter, letter)
        return digits + latin

    return text  # return unchanged if it doesn't match either format



df["Registre de commerce"] = df["Registre de commerce"].apply(convert_arabic_to_latin)


output_path = "/mnt/DRC_final_cleaned.xlsx"
df.to_excel(output_path, index=False)
print(f"✅ Cleaned file saved to: {output_path}")








Est-ce que tu pourrais nous partager les fichiers via Drive ? La personne qui a accès à SFS est en vacances, du coup on ne peut pas y accéder pour le moment.

Merci beaucoup !

À bientôt,
Nihad


def convert_arabic_to_latin(text):
    """
    Converts Arabic letters in a string to their corresponding Latin characters (e.g., ب -> B),
    only if Arabic letters follow two digits.
    """
    if not isinstance(text, str):
        return text

    arabic_to_latin = {
        "ا": "A", "أ": "A", "إ": "A",
        "ب": "B",
        "ت": "T",
        "ث": "TH",
        "ج": "J",
        "ح": "H",
        "خ": "KH",
        "د": "D",
        "ذ": "DH",
        "ر": "R",
        "ز": "Z",
        "س": "S",
        "ش": "CH",
        "ص": "S",
        "ض": "D",
        "ط": "T",
        "ظ": "Z",
        "ع": "A",
        "غ": "GH",
        "ف": "F",
        "ق": "Q",
        "ك": "K",
        "ل": "L",
        "م": "M",
        "ن": "N",
        "ه": "H",
        "و": "W",
        "ي": "Y",
    }

    import re

    match = re.match(r"^(\d{2})([^\d].*)", text)
    if match:
        first_two_digits = match.group(1)
        rest = match.group(2)
        converted = ''.join(arabic_to_latin.get(c, c) for c in rest)
        return first_two_digits + converted
    else:
        return text



df["Registre de commerce"] = df["Registre de commerce"].apply(convert_arabic_to_latin)



output_path = "/mnt/DRC_consolidated_cleaned.xlsx"
df.to_excel(output_path, index=False)
print(f"✅ Final cleaned file saved to: {output_path}")

