import os
import json
import datetime
import streamlit as st

CHAT_HISTORY_FILE = "chat_history.json"

def handle_chat_history(user_input=None, response=None, clear=False):
    if clear:
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        return

    # Load from file only if not already in session
    if "chat_sessions" not in st.session_state:
        if os.path.exists(CHAT_HISTORY_FILE):
            try:
                with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                    st.session_state.chat_sessions = json.load(f)
            except json.JSONDecodeError:
                st.session_state.chat_sessions = {}
        else:
            st.session_state.chat_sessions = {}

    # Do not create a new chat unless there is user input or response
    if (user_input or response):
        if "current_chat" not in st.session_state or not st.session_state.current_chat:
            st.session_state.current_chat = str(datetime.datetime.now())

        current_chat = st.session_state.current_chat

        if current_chat not in st.session_state.chat_sessions:
            st.session_state.chat_sessions[current_chat] = {
                "title": user_input[:30] if user_input else "New Chat",
                "messages": []
            }

        if user_input:
            st.session_state.chat_sessions[current_chat]["messages"].append({
                "role": "user",
                "content": user_input,
                "timestamp": datetime.datetime.now().isoformat()
            })

        if response:
            st.session_state.chat_sessions[current_chat]["messages"].append({
                "role": "assistant",
                "content": response,
                "timestamp": datetime.datetime.now().isoformat()
            })

        # Save to disk
        with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
            json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)



import os
import json
import datetime
import streamlit as st

CHAT_HISTORY_FILE = "chat_history.json"

def handle_chat_history(user_input=None, response=None, clear=False):
    if clear:
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        return

    # Load chat sessions from file if not already in session_state
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        if os.path.exists(CHAT_HISTORY_FILE):
            try:
                with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                    st.session_state.chat_sessions = json.load(f)
            except json.JSONDecodeError:
                st.session_state.chat_sessions = {}
        else:
            st.session_state.chat_sessions = {}

    # Set default current chat only if user explicitly triggers input
    if "current_chat" not in st.session_state or not st.session_state.current_chat:
        if user_input or response:
            st.session_state.current_chat = str(datetime.datetime.now())
        else:
            return  # No new chat should be created unless input or response exists

    current_chat = st.session_state.current_chat

    if current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[current_chat] = {
            "title": user_input[:30] if user_input else "New Chat",
            "messages": []
        }

    if user_input:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.datetime.now().isoformat()
        })

    if response:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "assistant",
            "content": response,
            "timestamp": datetime.datetime.now().isoformat()
        })

    # Save to file
    with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)




def main():
    st.title("Chatbot BNP ED")

    # Only call handler without user input to load previous sessions
    if "chat_sessions" not in st.session_state:
        handle_chat_history()

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # Sidebar: New Chat
    if st.sidebar.button("+ Start New Chat"):
        new_chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = new_chat_id
        st.session_state.chat_sessions[new_chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    if st.session_state.chat_sessions:
        chat_ids = list(st.session_state.chat_sessions.keys())

        selected_chat = st.sidebar.radio(
            "Chat Sessions",
            chat_ids,
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_ids.index(st.session_state.current_chat) if st.session_state.current_chat in chat_ids else 0
        )

        st.session_state.current_chat = selected_chat
        chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat, {"title": "New Chat", "messages": []})
        st.session_state.chat_sessions[st.session_state.current_chat] = chat_data

        # File uploader
        uploaded_file = st.sidebar.file_uploader("Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])
        chat = chat_data["messages"]

        if uploaded_file:
            existing = get_existing_sources()
            filename = uploaded_file.name.lower()

            if filename in existing:
                st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
            else:
                with st.spinner("‚è≥ Extracting and cleaning uploaded document..."):
                    raw_doc = extract_text_from_uploaded(uploaded_file)

                    if raw_doc is None:
                        st.sidebar.error("‚ùå Unsupported file format.")
                        return

                    docs = [raw_doc]
                    cleaned = clean_documents(docs)
                    temp_chunks = split_documents_semantic(cleaned)
                    st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")
        else:
            temp_chunks = []

        # Display chat history
        for message in chat:
            with st.chat_message(message["role"]):
                if message["role"] == "user" and "timestamp" in message:
                    st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
                st.markdown(message["content"], unsafe_allow_html=True)

        # Chat input
        user_input = st.chat_input("Type your message here...")
        if user_input:
            timestamp = datetime.datetime.now().isoformat()

            # Update chat title
            if chat_data["title"] == "New Chat":
                chat_data["title"] = user_input[:30]

            chat.append({
                "role": "user",
                "content": user_input,
                "timestamp": timestamp
            })

            with st.chat_message("assistant"):
                with st.spinner("Thinking..."):
                    response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                    answer = response["answer"]
                    st.markdown(answer, unsafe_allow_html=True)

                    st.session_state["last_answer"] = answer
                    chat.append({
                        "role": "assistant",
                        "content": answer,
                        "timestamp": datetime.datetime.now().isoformat()
                    })

            handle_chat_history(user_input=user_input, response=answer)

            if "last_answer" in st.session_state:
                show_copy_button(st.session_state["last_answer"])
                show_copy_and_download_buttons(st.session_state["last_answer"])




import streamlit as st
import datetime

def main():
    st.title("Chatbot BNP ED")

    handle_chat_history()

    # Initialize session state variables if not already present
    if "chat_sessions" not in st.session_state:
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # Sidebar: Start new chat button
    if st.sidebar.button("+ Start New Chat"):
        new_chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = new_chat_id
        st.session_state.chat_sessions[new_chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    # If any chat sessions exist, display them
    if st.session_state.chat_sessions:
        chat_ids = list(st.session_state.chat_sessions.keys())

        selected_chat = st.sidebar.radio(
            "Chat Sessions",
            chat_ids,
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_ids.index(st.session_state.current_chat)
            if st.session_state.current_chat in chat_ids else 0
        )

        st.session_state.current_chat = selected_chat

        chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)

        if not chat_data:
            chat_data = {"title": "New Chat", "messages": []}
            st.session_state.chat_sessions[st.session_state.current_chat] = chat_data

        # File uploader
        uploaded_file = st.sidebar.file_uploader("Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])

        chat = chat_data["messages"]

        if uploaded_file:
            existing = get_existing_sources()
            filename = uploaded_file.name.lower()

            if filename in existing:
                st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
            else:
                with st.spinner("‚è≥ Extracting and cleaning uploaded document..."):
                    raw_doc = extract_text_from_uploaded(uploaded_file)

                    if raw_doc is None:
                        st.sidebar.error("‚ùå Unsupported file format.")
                        return

                    docs = [raw_doc]
                    cleaned = clean_documents(docs)
                    temp_chunks = split_documents_semantic(cleaned)

                    st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")
        else:
            temp_chunks = []

        # Display chat history
        for message in chat:
            with st.chat_message(message["role"]):
                if message["role"] == "user" and "timestamp" in message:
                    st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
                st.markdown(message["content"], unsafe_allow_html=True)

        # Input for user message
        user_input = st.chat_input("Type your message here...")
        if user_input:
            handle_chat_history(user_input=user_input)

            timestamp = datetime.datetime.now().isoformat()

            # Update chat title if it's still default
            if chat_data["title"] == "New Chat":
                chat_data["title"] = user_input[:30]

            chat.append({
                "role": "user",
                "content": user_input,
                "timestamp": timestamp
            })

            with st.chat_message("assistant"):
                with st.spinner("Thinking..."):
                    response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                    answer = response["answer"]
                    st.markdown(answer, unsafe_allow_html=True)

                    st.session_state["last_answer"] = answer
                    handle_chat_history(response=answer)

                    chat.append({
                        "role": "assistant",
                        "content": answer,
                        "timestamp": datetime.datetime.now().isoformat()
                    })

            if "last_answer" in st.session_state:
                show_copy_button(st.session_state["last_answer"])
                show_copy_and_download_buttons(st.session_state["last_answer"])






def main():
    st.title("Chatbot BNP ED")

    handle_chat_history()

    # Initialize session state properly
    if "chat_sessions" not in st.session_state:
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    if st.sidebar.button("+ Start New Chat"):
        new_chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = new_chat_id
        st.session_state.chat_sessions[new_chat_id] = {
            "title": "New Chat", 
            "messages": []
        }

    if st.session_state.chat_sessions:
        chat_ids = list(st.session_state.chat_sessions.keys())

        selected_chat = st.sidebar.radio(
            "Chat Sessions", 
            chat_ids, 
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_ids.index(st.session_state.current_chat) if st.session_state.current_chat in chat_ids else 0
        )

        st.session_state.current_chat = selected_chat

        chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)

        if not chat_data:
            chat_data = {"title": "New Chat", "messages": []}
            st.session_state.chat_sessions[st.session_state.current_chat] = chat_data

        # File uploader and rest of your code continues...


from fpdf import FPDF
import streamlit as st
from fpdf.fonts import FontFace

def show_copy_and_download_buttons(answer_text: str):
    pdf = FPDF()
    pdf.add_page()

    # Use bundled FreeSans font from fpdf2
    pdf.set_font("helvetica", size=12)  # This works for basic Latin
    pdf.set_font("helvetica", size=12)

    # Safe fallback for limited unicode (√©, √ß, etc. ‚Äî not Arabic)
    for line in answer_text.split("\n"):
        try:
            pdf.multi_cell(0, 10, line)
        except UnicodeEncodeError:
            pdf.multi_cell(0, 10, line.encode("latin-1", "ignore").decode("latin-1"))

    pdf_bytes = pdf.output(dest="S").encode("latin-1")

    st.download_button(
        label="üìÑ Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )


https://github.com/dejavu-fonts/dejavu-fonts


from fpdf import FPDF
import streamlit as st
import os

def show_copy_and_download_buttons(answer_text: str):
    pdf = FPDF()
    pdf.add_page()

    # Use a Unicode-compatible font
    font_path = "fonts/DejaVuSans.ttf"  # Ensure this file exists
    if not os.path.exists(font_path):
        st.error("Font not found. Please place 'DejaVuSans.ttf' in a 'fonts/' folder.")
        return

    pdf.add_font("DejaVu", "", font_path, uni=True)
    pdf.set_font("DejaVu", size=12)

    for line in answer_text.split("\n"):
        pdf.multi_cell(0, 10, line)

    # Correct way to output PDF bytes
    pdf_bytes = pdf.output(dest="S").encode("latin1")

    st.download_button(
        label="üìÑ Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )


import streamlit as st
import datetime

def main():
    st.title("Chatbot BNP ED")

    if "chat_sessions" not in st.session_state:
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # Start new chat when button is clicked
    if st.sidebar.button("‚ûï Start New Chat"):
        chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = chat_id
        st.session_state.chat_sessions[chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    # Show chat session list
    if st.session_state.chat_sessions:
        chat_keys = list(st.session_state.chat_sessions.keys())
        titles = [st.session_state.chat_sessions[k]["title"] for k in chat_keys]

        selected = st.sidebar.radio(
            "Chat Sessions",
            chat_keys,
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_keys.index(st.session_state.current_chat) if st.session_state.current_chat in chat_keys else 0
        )
        st.session_state.current_chat = selected

    # Retrieve selected chat data
    chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)
    if not chat_data:
        return

    # Load and display chat history
    for message in chat_data["messages"]:
        with st.chat_message(message["role"]):
            if message["role"] != "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # Handle user input
    user_input = st.chat_input("Type your message here...")
    if user_input:
        timestamp = datetime.datetime.now().isoformat()
        if chat_data["title"] == "New Chat":
            chat_data["title"] = user_input[:30]

        chat_data["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

        chat_data["messages"].append({
            "role": "assistant",
            "content": answer,
            "timestamp": datetime.datetime.now().isoformat()
        })

        st.session_state["last_answer"] = answer

    # Copy + Download buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answe



import streamlit as st
import datetime

def main():
    st.title("Chatbot BNP ED")

    if "chat_sessions" not in st.session_state:
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # Start new chat when button is clicked
    if st.sidebar.button("‚ûï Start New Chat"):
        chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = chat_id
        st.session_state.chat_sessions[chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    # Show chat session list
    if st.session_state.chat_sessions:
        chat_keys = list(st.session_state.chat_sessions.keys())
        titles = [st.session_state.chat_sessions[k]["title"] for k in chat_keys]

        selected = st.sidebar.radio(
            "Chat Sessions",
            chat_keys,
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_keys.index(st.session_state.current_chat) if st.session_state.current_chat in chat_keys else 0
        )
        st.session_state.current_chat = selected

    # Retrieve selected chat data
    chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)
    if not chat_data:
        return

    # Load and display chat history
    for message in chat_data["messages"]:
        with st.chat_message(message["role"]):
            if message["role"] != "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # Handle user input
    user_input = st.chat_input("Type your message here...")
    if user_input:
        timestamp = datetime.datetime.now().isoformat()
        if chat_data["title"] == "New Chat":
            chat_data["title"] = user_input[:30]

        chat_data["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

        chat_data["messages"].append({
            "role": "assistant",
            "content": answer,
            "timestamp": datetime.datetime.now().isoformat()
        })

        st.session_state["last_answer"] = answer

    # Copy + Download buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answer"])




import streamlit as st
import datetime

def main():
    st.title("Chatbot BNP ED")

    # Initialize session state variables
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = None

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # Button to start a new chat
    if st.sidebar.button("‚ûï Start New Chat"):
        new_chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = new_chat_id
        st.session_state.chat_sessions[new_chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    # Show existing chat sessions
    if st.session_state.chat_sessions:
        chat_ids = list(st.session_state.chat_sessions.keys())
        selected_chat = st.sidebar.radio(
            "Chat Sessions",
            chat_ids,
            format_func=lambda x: st.session_state.chat_sessions[x]["title"],
            index=chat_ids.index(st.session_state.current_chat) if st.session_state.current_chat in chat_ids else 0
        )
        st.session_state.current_chat = selected_chat

    # Get current chat data
    chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)
    if not chat_data:
        chat_data = {"title": "New Chat", "messages": []}
        st.session_state.chat_sessions[st.session_state.current_chat] = chat_data

    chat = chat_data["messages"]
    temp_chunks = []

    # File upload
    uploaded_file = st.sidebar.file_uploader("Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])
    if uploaded_file:
        filename = uploaded_file.name.lower()
        existing = get_existing_sources()

        if filename in existing:
            st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
        else:
            with st.spinner("üìÑ Extracting and cleaning uploaded document..."):
                raw_doc = extract_text_from_uploaded(uploaded_file)
                if raw_doc is None:
                    st.sidebar.error("‚ùå Unsupported file format.")
                    return

                docs = [raw_doc]
                cleaned = clean_documents(docs)
                temp_chunks = split_documents_semantic(cleaned)
                st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")

    # Load chat history
    for message in chat:
        with st.chat_message(message["role"]):
            if message["role"] != "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # User input
    user_input = st.chat_input("Type your message here...")
    if user_input:
        timestamp = datetime.datetime.now().isoformat()

        # Rename chat title from "New Chat" to user prompt
        if chat_data["title"] == "New Chat":
            chat_data["title"] = user_input[:30]

        chat.append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

        chat.append({
            "role": "assistant",
            "content": answer,
            "timestamp": datetime.datetime.now().isoformat()
        })

        st.session_state["last_answer"] = answer

    # Show copy and download buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answer"])




def handle_chat_history(user_input=None, response=None, clear=False):
    CHAT_HISTORY_FILE = "chat_history.json"

    if clear:
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        return

    # Load from file if needed
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        if os.path.exists(CHAT_HISTORY_FILE):
            with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                try:
                    st.session_state.chat_sessions = json.load(f)
                except json.JSONDecodeError:
                    st.session_state.chat_sessions = {}
        else:
            st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state or not st.session_state.current_chat:
        st.session_state.current_chat = str(datetime.datetime.now())

    current_chat = st.session_state.current_chat

    if current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[current_chat] = {
            "title": user_input[:30] if user_input else "New Chat",
            "messages": []
        }

    if user_input:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.datetime.now().isoformat()
        })

    if response:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "assistant",
            "content": response,
            "timestamp": datetime.datetime.now().isoformat()
        })

    # Save back to file
    with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)



def main():
    import datetime
    st.title("üí¨ Chatbot BNP ED")

    # üîÅ Always load chat sessions from JSON
    handle_chat_history()

    # ‚úÖ Initialize session state
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state or not st.session_state.current_chat:
        st.session_state.current_chat = str(datetime.datetime.now())

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # ‚ûï New Chat Button
    if st.sidebar.button("+ Start New Chat"):
        new_chat_id = str(datetime.datetime.now())
        st.session_state.current_chat = new_chat_id
        st.session_state.chat_sessions[new_chat_id] = {
            "title": "New Chat",
            "messages": []
        }

    # üß† Chat selection sidebar
    if st.session_state.chat_sessions:
        selected = st.sidebar.radio(
            "üìÇ Chat Sessions",
            list(st.session_state.chat_sessions.keys()),
            index=list(st.session_state.chat_sessions.keys()).index(st.session_state.current_chat),
            format_func=lambda k: st.session_state.chat_sessions[k].get("title", k)
        )
        st.session_state.current_chat = selected

    # üóÇ Get current chat data
    chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat, {})
    messages = chat_data.get("messages", [])
    temp_chunks = []

    # üìé File uploader
    uploaded_file = st.sidebar.file_uploader("Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])
    if uploaded_file:
        filename = uploaded_file.name.lower()
        existing = get_existing_sources()
        if filename in existing:
            st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
        else:
            with st.spinner("Extracting and cleaning uploaded document..."):
                raw_doc = extract_text_from_uploaded(uploaded_file)
                if raw_doc is None:
                    st.sidebar.error("‚ùå Unsupported file format.")
                    return
                docs = [raw_doc]
                cleaned = clean_documents(docs)
                temp_chunks = split_documents_semantic(cleaned)
                st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")

    # üí¨ Show previous messages
    for message in messages:
        if not isinstance(message, dict) or "role" not in message or "content" not in message:
            continue  # skip corrupted messages
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # üí¨ Chat input
    user_input = st.chat_input("Type your message here...")
    if user_input:
        timestamp = datetime.datetime.now()

        # Set the title of new chat from first question
        if chat_data.get("title", "New Chat") == "New Chat":
            chat_data["title"] = user_input[:30]

        # Add user message
        messages.append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp.isoformat()
        })
        handle_chat_history(user_input=user_input)

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

                # Add assistant message
                messages.append({
                    "role": "assistant",
                    "content": answer,
                    "timestamp": datetime.datetime.now().isoformat()
                })
                st.session_state["last_answer"] = answer
                handle_chat_history(response=answer)

    # üìã Copy + PDF buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answer"])







import streamlit as st
import datetime

def main():
    st.title("üí¨ Chatbot BNP ED")

    # === Session State Initialization ===
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = str(datetime.datetime.now())

    if "copy_time" not in st.session_state:
        st.session_state.copy_time = datetime.datetime.now()

    # === New Chat Button ===
    if st.sidebar.button("‚ûï Start New Chat"):
        st.session_state.current_chat = str(datetime.datetime.now())
        st.session_state.chat_sessions[st.session_state.current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    # === Select Existing Chat Sessions (Left Sidebar) ===
    if st.session_state.chat_sessions:
        selected = st.sidebar.radio(
            "üóÇ Chat Sessions",
            list(st.session_state.chat_sessions.keys()),
            format_func=lambda k: st.session_state.chat_sessions[k].get("title", k),
            index=list(st.session_state.chat_sessions.keys()).index(st.session_state.current_chat)
        )
        st.session_state.current_chat = selected

    chat_data = st.session_state.chat_sessions.get(st.session_state.current_chat)
    if not chat_data:
        chat_data = {"title": "New Chat", "messages": []}
        st.session_state.chat_sessions[st.session_state.current_chat] = chat_data

    chat = chat_data["messages"]
    temp_chunks = []

    # === File Upload ===
    uploaded_file = st.sidebar.file_uploader("üìé Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])
    if uploaded_file:
        filename = uploaded_file.name.lower()
        existing = get_existing_sources()

        if filename in existing:
            st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
        else:
            with st.spinner("Extracting and cleaning uploaded document..."):
                raw_doc = extract_text_from_uploaded(uploaded_file)
                if raw_doc is None:
                    st.sidebar.error("‚ùå Unsupported file format.")
                    return

                docs = [raw_doc]
                cleaned = clean_documents(docs)
                temp_chunks = split_documents_semantic(cleaned)
                st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")

    # === Display Previous Chat
    for message in chat:
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # === Chat Input
    user_input = st.chat_input("Type your message here...")
    if user_input:
        timestamp = datetime.datetime.now()
        if chat_data["title"] == "New Chat":
            chat_data["title"] = user_input[:30] + "..."

        chat.append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp.isoformat()
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                answer = response["answer"]

                st.markdown(answer, unsafe_allow_html=True)

                chat.append({
                    "role": "assistant",
                    "content": answer,
                    "timestamp": datetime.datetime.now().isoformat()
                })

                st.session_state.last_answer = answer
                show_copy_and_download_buttons(answer)  # ‚úÖ copy + download




def handle_chat_history(user_input=None, response=None, clear=False):
    if clear:
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        return

    # Load from file
    if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
        if os.path.exists(CHAT_HISTORY_FILE):
            with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                st.session_state.chat_sessions = json.load(f)
        else:
            st.session_state.chat_sessions = {}

    if "current_chat" not in st.session_state:
        st.session_state.current_chat = str(datetime.datetime.now())

    current_chat = st.session_state.current_chat

    if current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    if user_input:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.datetime.now().isoformat()
        })

    if response:
        st.session_state.chat_sessions[current_chat]["messages"].append({
            "role": "assistant",
            "content": response,
            "timestamp": datetime.datetime.now().isoformat()
        })

    # Save to file
    with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)




if clear:
    st.session_state.chat_sessions = {}  # ‚úÖ dictionary, not list
    st.session_state.current_chat = None
    if os.path.exists(CHAT_HISTORY_FILE):
        os.remove(CHAT_HISTORY_FILE)
    return



# Load chat sessions from file
if "chat_sessions" not in st.session_state:
    if os.path.exists(CHAT_HISTORY_FILE):
        with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
            st.session_state.chat_sessions = json.load(f)
    else:
        st.session_state.chat_sessions = {}  # ‚úÖ always dict



if "chat_sessions" not in st.session_state or not isinstance(st.session_state.chat_sessions, dict):
    st.session_state.chat_sessions = {}  # ‚úÖ correct: initialize as dict







import streamlit as st
import datetime

def main():
    st.title("üí¨ Chatbot BNP ED")

    # === Load and display chat sessions in sidebar ===
    st.sidebar.title("üóÇ Chat History")
    handle_chat_history()  # Make sure sessions are loaded

    session_titles = {
        key: value["title"] for key, value in st.session_state.chat_sessions.items()
    }

    if session_titles:
        selected_session = st.sidebar.radio("Select a chat", list(session_titles.keys()),
                                            format_func=lambda k: session_titles[k])
        st.session_state.current_chat = selected_session
    else:
        # No previous sessions
        st.session_state.current_chat = str(datetime.datetime.now())

    if st.sidebar.button("‚ûï Start New Chat"):
        st.session_state.current_chat = str(datetime.datetime.now())

    if st.sidebar.button("üóë Clear All Chats"):
        handle_chat_history(clear=True)
        st.experimental_rerun()

    # === Prepare current chat ===
    if st.session_state.current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[st.session_state.current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    chat_data = st.session_state.chat_sessions[st.session_state.current_chat]
    chat = chat_data["messages"]
    temp_chunks = []

    # === Upload document ===
    uploaded_file = st.sidebar.file_uploader("üìé Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])

    if uploaded_file:
        filename = uploaded_file.name.lower()
        existing = get_existing_sources()

        if filename in existing:
            st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
        else:
            with st.spinner("Extracting and cleaning uploaded document..."):
                raw_doc = extract_text_from_uploaded(uploaded_file)

                if raw_doc is None:
                    st.sidebar.error("‚ùå Unsupported file format.")
                    return

                docs = [raw_doc]
                cleaned = clean_documents(docs)
                temp_chunks = split_documents_semantic(cleaned)

                st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")

    # === Display previous messages ===
    for message in chat:
        if not isinstance(message, dict) or "role" not in message or "content" not in message:
            continue  # Skip invalid messages
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # === Chat input box ===
    user_input = st.chat_input("Type your message here...")

    if user_input:
        timestamp = datetime.datetime.now()

        # Save user input
        handle_chat_history(user_input=user_input)

        # Show user message immediately
        chat.append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp.isoformat()
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

                st.session_state["last_answer"] = answer
                handle_chat_history(response=answer)

    # === Copy / Download buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answer"])








import streamlit as st
import datetime

def main():
    st.title("üí¨ Chatbot BNP ED")

    # === Load and display chat sessions in sidebar ===
    st.sidebar.title("üóÇ Chat History")
    handle_chat_history()  # Make sure sessions are loaded

    session_titles = {
        key: value["title"] for key, value in st.session_state.chat_sessions.items()
    }

    if session_titles:
        selected_session = st.sidebar.radio("Select a chat", list(session_titles.keys()),
                                            format_func=lambda k: session_titles[k])
        st.session_state.current_chat = selected_session
    else:
        # No previous sessions
        st.session_state.current_chat = str(datetime.datetime.now())

    if st.sidebar.button("‚ûï Start New Chat"):
        st.session_state.current_chat = str(datetime.datetime.now())

    if st.sidebar.button("üóë Clear All Chats"):
        handle_chat_history(clear=True)
        st.experimental_rerun()

    # === Prepare current chat ===
    if st.session_state.current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[st.session_state.current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    chat_data = st.session_state.chat_sessions[st.session_state.current_chat]
    chat = chat_data["messages"]
    temp_chunks = []

    # === Upload document ===
    uploaded_file = st.sidebar.file_uploader("üìé Upload a document (optional)", type=["pdf", "txt", "docx", "csv", "xlsx"])

    if uploaded_file:
        filename = uploaded_file.name.lower()
        existing = get_existing_sources()

        if filename in existing:
            st.sidebar.warning("‚ö†Ô∏è This file is already indexed in ChromaDB.")
        else:
            with st.spinner("Extracting and cleaning uploaded document..."):
                raw_doc = extract_text_from_uploaded(uploaded_file)

                if raw_doc is None:
                    st.sidebar.error("‚ùå Unsupported file format.")
                    return

                docs = [raw_doc]
                cleaned = clean_documents(docs)
                temp_chunks = split_documents_semantic(cleaned)

                st.sidebar.success(f"‚úÖ File loaded with {len(temp_chunks)} temporary chunks.")

    # === Display previous messages ===
    for message in chat:
        if not isinstance(message, dict) or "role" not in message or "content" not in message:
            continue  # Skip invalid messages
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_", unsafe_allow_html=True)
            st.markdown(message["content"], unsafe_allow_html=True)

    # === Chat input box ===
    user_input = st.chat_input("Type your message here...")

    if user_input:
        timestamp = datetime.datetime.now()

        # Save user input
        handle_chat_history(user_input=user_input)

        # Show user message immediately
        chat.append({
            "role": "user",
            "content": user_input,
            "timestamp": timestamp.isoformat()
        })

        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = rag_chatbot(user_input, temp_chunks=temp_chunks)
                answer = response["answer"]
                st.markdown(answer, unsafe_allow_html=True)

                st.session_state["last_answer"] = answer
                handle_chat_history(response=answer)

    # === Copy / Download buttons
    if "last_answer" in st.session_state:
        show_copy_button(st.session_state["last_answer"])
        show_copy_and_download_buttons(st.session_state["last_answer"])import os
import json
import datetime

CHAT_HISTORY_FILE = "chat_history.json"

def handle_chat_history(user_input=None, response=None, clear=False):
    """
    Manages all chat history:
    - Initializes session state
    - Creates new sessions
    - Stores chat messages with timestamps
    - Saves to and loads from disk
    - Can clear all history
    """
    # === Load or initialize chat sessions
    if "chat_sessions" not in st.session_state:
        if os.path.exists(CHAT_HISTORY_FILE):
            with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                st.session_state.chat_sessions = json.load(f)
        else:
            st.session_state.chat_sessions = {}

    if clear:
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        return

    # === Set up current chat session
    if "current_chat" not in st.session_state or st.session_state.current_chat is None:
        st.session_state.current_chat = str(datetime.datetime.now())

    # === Create session if it doesn't exist
    if st.session_state.current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[st.session_state.current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    session = st.session_state.chat_sessions[st.session_state.current_chat]

    # === Add user message
    if user_input:
        session["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.datetime.now().isoformat()
        })

        # Set title if first user message
        if session["title"] == "New Chat":
            session["title"] = user_input[:30] + "..."

    # === Add assistant response
    if response:
        session["messages"].append({
            "role": "assistant",
            "content": response,
            "timestamp": datetime.datetime.now().isoformat()
        })

    # === Save sessions to disk
    with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)



st.sidebar.title("üí¨ Chat History")

# Load session history
handle_chat_history()

# Sidebar session list
session_titles = {
    key: value["title"] for key, value in st.session_state.chat_sessions.items()
}

# Let user pick a session
if session_titles:
    selected_session = st.sidebar.radio("Select a chat", list(session_titles.keys()),
                                        format_func=lambda k: session_titles[k])
    st.session_state.current_chat = selected_session

# New chat button
if st.sidebar.button("‚ûï Start New Chat"):
    st.session_state.current_chat = str(datetime.datetime.now())

# Clear all
if st.sidebar.button("üóë Clear All Chats"):
    handle_chat_history(clear=True)
    st.experimental_rerun()









from fpdf import FPDF
import base64

def show_copy_and_download_buttons(answer_text: str):
    # === PDF creation
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in answer_text.split("\n"):
        pdf.multi_cell(0, 10, line)
    pdf_bytes = pdf.output(dest="S").encode("latin-1")

    # === PDF download button
    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )
import streamlit.components.v1 as components

def show_copy_button(text_to_copy: str):
    components.html(f"""
        <script>
        function copyText() {{
            const text = `{text_to_copy}`;
            navigator.clipboard.writeText(text).then(function() {{
                alert("‚úÖ Answer copied to clipboard!");
            }}, function(err) {{
                alert("‚ùå Failed to copy text: " + err);
            }});
        }}
        </script>
        <button onclick="copyText()" style="
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 15px;
        ">üìã Copy Answer to Clipboard</button>
    """, height=50)



if user_input:
    handle_chat_history(user_input=user_input)

    with st.chat_message("assistant"):
        with st.spinner("Thinking..."):
            response = rag_chatbot(user_input, temp_chunks=temp_chunks)
            answer = response["answer"]

            st.markdown(answer, unsafe_allow_html=True)

            st.session_state["last_answer"] = answer  # üíæ Save for reuse
            handle_chat_history(response=answer)

# === Show Copy & Download Buttons if answer exists
if "last_answer" in st.session_state:
    show_copy_button(st.session_state["last_answer"])
    show_copy_and_download_buttons(st.session_state["last_answer"])










def show_copy_and_download_buttons(answer_text):
    # === Manual Copy Option
    with st.expander("üìã Copy Answer"):
        st.text_area("Copy the answer manually:", value=answer_text, height=200)

    # === PDF Download
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in answer_text.split("\n"):
        pdf.multi_cell(0, 10, line)

    pdf_bytes = pdf.output(dest="S").encode("latin-1")  # Fresh bytes each time

    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )



def create_pdf_from_text(text):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    for line in text.split("\n"):
        pdf.multi_cell(0, 10, line)

    # Generate PDF as string
    pdf_output = pdf.output(dest='S').encode('latin-1')  # PDF raw bytes
    return pdf_output



def show_copy_and_download_buttons(answer_text):
    # Copy to clipboard (browser only)
    st.markdown(
        f"""
        <button onclick="navigator.clipboard.writeText(`{answer_text}`)"
        style="background-color:#4CAF50;color:white;padding:10px;border:none;border-radius:5px;margin-bottom:10px;">
        üìã Copy Answer to Clipboard
        </button>
        """,
        unsafe_allow_html=True,
    )

    # PDF download
    pdf_bytes = create_pdf_from_text(answer_text)
    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )



