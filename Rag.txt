# Chat Messages
if st.session_state.current_chat:
    chat = st.session_state.chat_sessions[st.session_state.current_chat]
    
    for idx, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"_{message['timestamp']}_")
                st.markdown(message["content"])
            elif message["role"] == "assistant":
                st.markdown(message["content"], unsafe_allow_html=True)
                
                # Copy Button with actual clipboard functionality
                now = time.time()
                key = f"copy_{idx}"
                
                # Show "Copied" for 10 seconds after clicking
                if st.session_state.copy_time.get(key, 0) > (now - 10):
                    if st.button("‚úì Copied", key=key):
                        st.session_state.copy_time[key] = now
                        st_copy_to_clipboard(message["content"])
                else:
                    if st.button("Copy", key=key):
                        st.session_state.copy_time[key] = now
                        st_copy_to_clipboard(message["content"])
                        st.rerun()  # Refresh to show the "Copied" state

# Chat Input
user_input = st.chat_input("Type your message here...")

if user_input:
    timestamp = datetime.datetime.now()
    chat.append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp.strftime("%Y-%m-%d %H:%M:%S")
    })
    
    with st.spinner("Thinking..."):
        response = rag_chatbot(user_input)
        answer = response["answer"]
        
        st.markdown("**Assistant:**")
        st.markdown(answer, unsafe_allow_html=True)
        
        chat.append({
            "role": "assistant",
            "content": answer,
            "timestamp": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })






import streamlit as st
from datetime import datetime
import time

# Initialize session state
if "chat_sessions" not in st.session_state:
    st.session_state["chat_sessions"] = {}

if "copy_time" not in st.session_state:
    st.session_state["copy_time"] = {}

# Set current chat session (for example, can be selected by the user)
st.title("Chatbot BNP ED")
current_chat = st.session_state.get("current_chat", None)

# Ensure chat history exists for the current session
if current_chat:
    chat = st.session_state.chat_sessions[current_chat]
    
    # Display chat messages
    for idx, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"({message['timestamp']})")
            st.markdown(message["content"], unsafe_allow_html=True)

            if message["role"] == "assistant":
                # Copy button for the assistant's response
                now = time.time()
                key = f"copy_{idx}"
                show_copied = False
                label = "Copy"  # Default label

                # Show "Copied" if copied within the last 10 seconds
                if st.session_state.copy_time.get(key, 0) > now - 10:
                    label = "Copied ‚úÖ"
                    show_copied = True

                if st.button(label, key=key):
                    # Save the copy time and the content for later use
                    st.session_state.copy_time[key] = now
                    st.session_state[f"copy_text_{key}"] = message["content"]

                # Display copied content in code block
                if show_copied:
                    st.code(message["content"], language="text")

# User input field
user_input = st.chat_input("Type your message here...")

if user_input:
    timestamp = datetime.now()
    
    # Add user's message to the chat history
    chat.append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    # Simulate assistant's response
    with st.spinner("Thinking..."):
        response = "This is a dummy response. Replace with your model's output."
        answer = response
        
        # Display assistant's response
        st.markdown("**Assistant:**")
        st.markdown(answer, unsafe_allow_html=True)

        # Add assistant's message to the chat history
        chat.append({
            "role": "assistant",
            "content": answer,
            "timestamp": datetime.now()
        })





import streamlit as st
from PIL import Image
import datetime
import time

# --- Setup ---
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}

if "current_chat" not in st.session_state:
    st.session_state.current_chat = None

if "copy_time" not in st.session_state:
    st.session_state.copy_time = {}

# --- Logo ---
image = Image.open("/mnt/bnp logo.png")
st.image(image)

# --- Sidebar ---
with st.sidebar:
    st.header("Chat Sessions")

    if st.button("+ New Chat"):
        chat_id = len(st.session_state.chat_sessions) + 1
        chat_name = f"Chat {chat_id}"
        st.session_state.chat_sessions[chat_name] = []
        st.session_state.current_chat = chat_name

    if st.session_state.chat_sessions:
        options = []
        for key, messages in st.session_state.chat_sessions.items():
            label = key
            for m in messages:
                if m["role"] == "user":
                    snippet = m["content"][:30] + ("..." if len(m["content"]) > 30 else "")
                    label = f"{key}: {snippet}"
                    break
            options.append(label)

        selected = st.radio("Select Chat", options)
        selected_key = selected.split(":")[0]
        st.session_state.current_chat = selected_key

# --- Title ---
st.title("Chatbot BNP ED")

# --- Chat Messages ---
if st.session_state.current_chat:
    chat = st.session_state.chat_sessions[st.session_state.current_chat]

    for idx, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"**üïí {message['timestamp']}**")
                st.markdown(message["content"])
            elif message["role"] == "assistant":
                st.markdown(message["content"], unsafe_allow_html=True)

                # Copy Button
                now = time.time()
                key = f'copy_{idx}'
                show_copied = False

                if st.session_state.copy_time.get(key, 0) > now - 10:
                    label = "‚úÖ Copied"
                    show_copied = True
                else:
                    label = "üìã Copy"

                if st.button(label, key=key):
                    st.session_state.copy_time[key] = now
                    st.session_state["copy_text"] = message["content"]

                if show_copied:
                    st.code(message["content"], language="text")

# --- Chat Input ---
user_input = st.chat_input("Type your message here...")

if user_input:
    timestamp = datetime.datetime.now()
    chat.append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    with st.spinner("Thinking..."):
        # Dummy response - replace with your actual model call
        response = {"answer": f"Echo: {user_input}"}

    answer = response["answer"]
    chat.append({
        "role": "assistant",
        "content": answer,
        "timestamp": datetime.datetime.now()
    })





import streamlit as st
import time

# Initialize session state
if "chat_history" not in st.session_state:
    st.session_state["chat_history"] = []

if "copy_time" not in st.session_state:
    st.session_state["copy_time"] = {}

# Display chat history
for idx, msg in enumerate(st.session_state["chat_history"]):
    key = f"copy_{idx}"
    now = time.time()
    show_copied = False

    with st.chat_message(msg["role"]):
        st.markdown(msg["content"], unsafe_allow_html=True)

        if msg["role"] == "assistant":
            if st.session_state["copy_time"].get(key, 0) > now - 10:
                label = "Copi√© ‚úÖ"
                show_copied = True
            else:
                label = "Copier la r√©ponse"

            if st.button(label, key=key):
                st.session_state["copy_time"][key] = now
                st.session_state[f"copy_text_{key}"] = msg["content"]

            if show_copied:
                st.code(msg["content"], language="text")








st.session_state.setdefault('chat_history', [])
st.session_state['chat_history'].append("Hello again!")


import streamlit as st
import time

# Initialize session state variables if they don't exist
if "chat_history" not in st.session_state:
    st.session_state.chat_history = [
        {"role": "user", "content": "Hello, how are you?"},
        {"role": "assistant", "content": "I'm fine, thank you! How can I assist you today?"}
    ]

if "copy_time" not in st.session_state:
    st.session_state.copy_time = {}

# Display the chat history
for idx, msg in enumerate(st.session_state.chat_history):
    with st.chat_message(msg["role"]):
        st.markdown(msg["content"], unsafe_allow_html=True)

        if msg["role"] == "assistant":
            key = f"copy_{idx}"
            now = time.time()
            show_copied = False

            # Show "Copi√©" if copied in last 10 seconds
            if st.session_state.copy_time.get(key, 0) > now - 10:
                label = "Copi√©"
                show_copied = True
            else:
                label = "Copier la r√©ponse"

            if st.button(label, key=key):
                st.session_state.copy_time[key] = now
                st.session_state[f"copy_text_{key}"] = msg["content"]

            if show_copied:
                st.code(msg["content"], language="text")






Dear Jean-Baptiste,

Thank you for your message.

To clarify, I did click the synchronization button multiple times. However, I misunderstood your earlier mention of Git ‚Äî I thought you were referring to the git push syntax specifically.

I plan to create a whole new project to avoid any further issues. I believe the problem was caused by Chroma DB ‚Äî when I used FAISS as the backend, everything worked fine without any similar behavior.

As soon as I regain access, I will delete the Chroma-related files. At the moment, I‚Äôm unable to remove them.

Best regards,
Nihad Senhadji


Bonjour Xavier,

Je vous remercie pour votre message.

Je vous confirme que je n‚Äôai pas utilis√© Git ni ex√©cut√© le workspace concern√© depuis le 16 mai 2025. Je ne suis donc pas √† l‚Äôorigine de la synchronisation mentionn√©e.

Par ailleurs, concernant l‚Äôacc√®s √† l‚ÄôAPI Azure OpenAI, la demande ne me concerne pas directement ‚Äî elle a √©t√© faite pour Omar, et non pour moi.

Vous trouverez ci-joint une capture d‚Äô√©cran montrant l‚Äôabsence de synchronisation de la base vectorielle depuis environ un mois.

N‚Äôh√©sitez pas √† revenir vers moi si besoin.

Bien cordialement,
Nihad Senhadji




Bonjour Xavier,

Je vous remercie pour votre message.

Je vous confirme que je n‚Äôai pas utilis√© Git ni ex√©cut√© le workspace concern√© depuis le 16 mai 2025. Je ne suis donc pas √† l‚Äôorigine de la synchronisation mentionn√©e.

Par ailleurs, concernant l‚Äôacc√®s √† l‚ÄôAPI Azure OpenAI, la demande ne me concerne pas directement ‚Äî elle a √©t√© faite pour Omar, et non pour moi.

N‚Äôh√©sitez pas √† me faire savoir si vous avez besoin d‚Äôinformations compl√©mentaires.

Bien cordialement,
Nihad Senhadji


import streamlit as st
from datetime import datetime
import time

# Initialize session state
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}
if "current_chat" not in st.session_state:
    st.session_state.current_chat = "default"
if st.session_state.current_chat not in st.session_state.chat_sessions:
    st.session_state.chat_sessions[st.session_state.current_chat] = []
if "copy_time" not in st.session_state:
    st.session_state.copy_time = {}

chat = st.session_state.chat_sessions[st.session_state.current_chat]

# User input
user_input = st.chat_input("Type your message here...")

if user_input:
    timestamp = datetime.now()
    chat.append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    # Simulate assistant response
    with st.spinner("Thinking..."):
        response = {"answer": f"This is a response to: {user_input}"}
    answer = response["answer"]

    # Save assistant message
    chat.append({
        "role": "assistant",
        "content": answer,
        "timestamp": datetime.now()
    })

# Display full conversation
for idx, msg in enumerate(chat):
    with st.chat_message(msg["role"]):
        st.markdown(msg["content"], unsafe_allow_html=True)

        if msg["role"] == "assistant":
            key = f"copy_{idx}"
            now = time.time()
            show_copied = False

            # Show "Copied" if copied in last 10 seconds
            if st.session_state.copy_time.get(key, 0) > now - 10:
                label = "‚úÖ Copi√©"
                show_copied = True
            else:
                label = "üìã Copier la r√©ponse"

            if st.button(label, key=key):
                st.session_state.copy_time[key] = time.time()
                st.session_state[f"copy_text_{key}"] = msg["content"]

            # Hidden textarea + JS trick (can be skipped if not needed)
            if show_copied:
                st.code(msg["content"], language="text")



Bonjour [Nom],

Apr√®s r√©ception des fichiers envoy√©s, nous avons constat√© un √©cart important par rapport aux mois pr√©c√©dents.
Le volume de fichiers transmis ce mois-ci est nettement inf√©rieur.
Voici le d√©tail de l‚Äô√©cart : [ajoutez les chiffres ou informations].
Merci de v√©rifier de votre c√¥t√©.
Cordialement,
[Votre nom]





Objet : Acc√®s API ChatGPT pour Omar

Bonjour,
Je souhaite obtenir les credentials (cl√© API, ID organisation, etc.) de l‚ÄôAPI ChatGPT pour mon manager Omar, afin qu‚Äôil puisse l‚Äôutiliser dans le cadre de notre projet. Merci de me transmettre les informations n√©cessaires ou la proc√©dure √† suivre.



import os
import pandas as pd
import csv

# Root folder containing Excel files
root_folder = "/mnt/sheets/Liste des personnes physiques-morales non localiser"

# Output CSV file
output_path = "/mnt/excel_all_sheets_summary.csv"

with open(output_path, mode="w", encoding="utf-8-sig", newline='') as csv_file:
    writer = csv.writer(csv_file)
    writer.writerow(["FilePath", "SheetName", "RowData"])  # Header

    for dirpath, dirnames, filenames in os.walk(root_folder):
        for file in filenames:
            if file.endswith((".xlsx", ".xls")) and not file.startswith("-5"):
                file_path = os.path.join(dirpath, file)
                try:
                    xls = pd.ExcelFile(file_path)
                    print(f"\nüìÑ File: {file} contains sheets: {xls.sheet_names}")  # Debug info

                    for sheet_name in xls.sheet_names:
                        try:
                            df = pd.read_excel(xls, sheet_name=sheet_name, dtype=str, header=None)
                            df.fillna("", inplace=True)
                            for _, row in df.iterrows():
                                row_data = "|".join(row.astype(str))
                                writer.writerow([file_path, sheet_name, row_data])
                        except Exception as e:
                            print(f"‚ùå Error reading sheet '{sheet_name}' in '{file}': {e}")
                except Exception as e:
                    print(f"‚ùå Error opening file '{file}': {e}")

print(f"\n‚úÖ All data saved to: {output_path}")




import os
import pandas as pd
import csv

# Root folder containing Excel files
root_folder = "/mnt/sheets/Liste des personnes physiques-morales non localiser"

# Output CSV file
output_path = "/mnt/excel_all_sheets_summary.csv"

# Open CSV file with utf-8 encoding to handle Arabic
with open(output_path, mode="w", encoding="utf-8-sig", newline='') as csv_file:
    writer = csv.writer(csv_file)
    # Header
    writer.writerow(["FilePath", "SheetName", "RowData"])

    # Walk through all files and folders
    for dirpath, dirnames, filenames in os.walk(root_folder):
        for file in filenames:
            if file.endswith((".xlsx", ".xls")) and not file.startswith("-5"):
                file_path = os.path.join(dirpath, file)
                try:
                    xls = pd.ExcelFile(file_path)
                    for sheet_name in xls.sheet_names:
                        try:
                            df = pd.read_excel(file_path, sheet_name=sheet_name, dtype=str, header=None)
                            df.fillna("", inplace=True)
                            for _, row in df.iterrows():
                                row_data = "|".join(row.astype(str))
                                writer.writerow([file_path, sheet_name, row_data])
                        except Exception as e:
                            print(f"Error reading sheet '{sheet_name}' in '{file}': {e}")
                except Exception as e:
                    print(f"Error opening file '{file}': {e}")

print(f"‚úÖ All data saved to: {output_path}")




import os
import pandas as pd

# Root folder where Excel files are located
root_folder = "/mnt/sheets/Liste des personnes physiques-morales non localiser"

# Open output file for writing
output_path = "/mnt/excel_merged_sheets.txt"
with open(output_path, "w", encoding="utf-8") as f_out:
    # Loop through all Excel files
    for dirpath, dirnames, filenames in os.walk(root_folder):
        for file in filenames:
            if file.endswith((".xlsx", ".xls")) and not file.startswith("-5"):
                file_path = os.path.join(dirpath, file)
                try:
                    xls = pd.ExcelFile(file_path)
                    for sheet_name in xls.sheet_names:
                        try:
                            df = pd.read_excel(file_path, sheet_name=sheet_name, dtype=str, header=None)
                            df.fillna("", inplace=True)

                            for _, row in df.iterrows():
                                row_data = "|".join(row.astype(str))
                                f_out.write(f"{row_data} | FilePath: {file_path} | SheetName: {sheet_name}\n")
                        except Exception as e:
                            print(f"Error reading sheet '{sheet_name}' in {file}: {e}")
                except Exception as e:
                    print(f"Error opening file '{file}': {e}")

print(f"All sheet data saved to: {output_path}")




import os
import pandas as pd

# Root folder where Excel files are located
root_folder = "/mnt/sheets/Liste des personnes physiques-morales non localiser"

# Container for all rows from all sheets
all_data = []

# Traverse the directory and process each Excel file
for dirpath, dirnames, filenames in os.walk(root_folder):
    for file in filenames:
        if file.endswith((".xlsx", ".xls")) and not file.startswith("-5"):
            file_path = os.path.join(dirpath, file)
            try:
                xls = pd.ExcelFile(file_path)
                for sheet_name in xls.sheet_names:
                    try:
                        df = pd.read_excel(file_path, sheet_name=sheet_name, dtype=str, header=None)
                        df.fillna("", inplace=True)  # Replace NaNs with empty strings

                        # Add file metadata columns
                        df["FilePath"] = file_path
                        df["SheetName"] = sheet_name

                        all_data.append(df)
                    except Exception as e:
                        print(f"Error reading sheet '{sheet_name}' in {file}: {e}")
            except Exception as e:
                print(f"Error opening file '{file}': {e}")

# Combine everything into one DataFrame
if all_data:
    merged_df = pd.concat(all_data, ignore_index=True)

    # Save to a single CSV file
    merged_output_path = "/mnt/excel_merged_sheets.csv"
    merged_df.to_csv(merged_output_path, index=False, encoding="utf-8-sig")
    print(f"All sheet data saved to: {merged_output_path}")
else:
    print("No data was processed.")






import os
import pandas as pd

# Root folder where Excel files are located
root_folder = "/mnt/sheets/Liste des personnes physiques-morales non localiser"

# Container for summary info
sheet_summary = []

# Loop through all subdirectories and files
for dirpath, dirnames, filenames in os.walk(root_folder):
    for file in filenames:
        if file.endswith((".xlsx", ".xls")) and not file.startswith("-5"):
            file_path = os.path.join(dirpath, file)
            try:
                xls = pd.ExcelFile(file_path)
                for sheet_name in xls.sheet_names:
                    try:
                        df = pd.read_excel(file_path, sheet_name=sheet_name, dtype=str, header=None)
                        # Fill NaNs and convert the entire sheet to a single string
                        sheet_content = df.fillna("").astype(str).apply(lambda x: "|".join(x), axis=1).str.cat(sep="\n")
                        sheet_summary.append({
                            "FileName": file,
                            "SheetName": sheet_name,
                            "FilePath": file_path,
                            "SheetContent": sheet_content
                        })
                    except Exception as e:
                        print(f"Error reading sheet '{sheet_name}' in {file}: {e}")
            except Exception as e:
                print(f"Error opening file '{file}': {e}")

# Convert to DataFrame and export
if sheet_summary:
    summary_df = pd.DataFrame(sheet_summary)

    # Save to CSV
    csv_output_path = "/mnt/excel_sheet_summaries.csv"
    summary_df.to_csv(csv_output_path, index=False)
    print(f"Sheet summaries saved to: {csv_output_path}")

    # Save to TXT
    txt_output_path = "/mnt/excel_sheet_summaries.txt"
    with open(txt_output_path, "w", encoding="utf-8") as f:
        for entry in sheet_summary:
            f.write(f"FileName: {entry['FileName']}\n")
            f.write(f"SheetName: {entry['SheetName']}\n")
            f.write(f"FilePath: {entry['FilePath']}\n")
            f.write(f"SheetContent:\n{entry['SheetContent']}\n")
            f.write("="*80 + "\n")
    print(f"Sheet summaries also saved to: {txt_output_path}")
else:
    print("No sheets found or readable.")

