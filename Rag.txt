APA (Analytic Process Automation) is a technology that combines data analytics, automation, and data science to streamline business processes. It allows users to gather, analyze, and act on data quickly‚Äîreducing manual work and improving decision-making.



Why it is difficult

Data storage in Excel files, disconnected from core systems

Matching of domiciliation and payment per transaction

Identification of the currency source: Central Bank or client‚Äôs own funds

Compliance with strict Central Bank formatting rules

Daily submission deadline with no margin for error





1. Introduction ‚Äì Why this presentation

Hello everyone,

I will show you how we built a simple solution using Alteryx to produce a regulatory report for the Central Bank.

It‚Äôs a real use case. The goal is to explain how we do it, step by step.

‚∏ª

2. Business context

Every day, we must send a report to the Central Bank of Algeria.

This report includes Trade Finance operations:
	‚Ä¢	Letters of Credit
	‚Ä¢	Documentary Collections
	‚Ä¢	Free Transfers

The data comes from two different tools:
	‚Ä¢	Carthago Dom for domiciliations
	‚Ä¢	Carthago Trade for payments (settlements)

We also use a third file: a list of clients who can access the dealing room.

‚∏ª

3. Why it is difficult

This report is hard to produce because:
	‚Ä¢	The data is in Excel files (not connected to our main system)
	‚Ä¢	We must match domiciliation and payment for each transaction
	‚Ä¢	We must check if the currency comes from the Central Bank or from client‚Äôs own funds
	‚Ä¢	The format must follow strict rules from the Central Bank
	‚Ä¢	And we must do this every day, with no mistakes

‚∏ª

4. How we do it ‚Äì our method

We created an APA (Analytic Process Automation) using Alteryx Designer.

Each day, we extract 3 Excel files:
	1.	One from Carthago Trade
	2.	One from Carthago Dom
	3.	One with the list of authorized clients

The user opens the Alteryx workflow, uploads the 3 files, and clicks ‚ÄúOK‚Äù.

‚∏ª

5. What the workflow does

The Alteryx workflow does everything:

Step 1: Clean and filter the 3 files
	‚Ä¢	Clean amounts, dates, formats
	‚Ä¢	Keep only needed lines

Step 2:
	‚Ä¢	Detect currency types (EUR, USD, etc.)
	‚Ä¢	Classify each operation (currency purchase, own funds, etc.)
	‚Ä¢	Standardize names and formats

Step 3:
	‚Ä¢	Match domiciliation and payment
	‚Ä¢	Add the client list
	‚Ä¢	Check the data with business rules
	‚Ä¢	Highlight problems in red

‚∏ª

6. Live demo

I will now show you how it works:
	‚Ä¢	I open the workflow
	‚Ä¢	Upload the 3 Excel files
	‚Ä¢	Run the process
	‚Ä¢	And get the final file, ready to send to the Central Bank

If there are errors, they are marked in red.

‚∏ª

7. What happens if there are errors

If we see problems in the report:
	‚Ä¢	The reporting team contacts the business team
	‚Ä¢	They correct the source data in Carthago
	‚Ä¢	Then we upload the new files
	‚Ä¢	And run the workflow again to get a clean report

‚∏ª

8. Conclusion ‚Äì Why this is useful

Thanks to this process:
	‚Ä¢	We save time
	‚Ä¢	We reduce manual errors
	‚Ä¢	We have good quality and full traceability

This is not a big system. It is a small, smart solution.








def copy_to_clipboard_button(text: str, label="üìã Copier la r√©ponse"):
    copy_code = f"""
        <button onclick="navigator.clipboard.writeText(`{text}`)"
        style="padding: 0.5em 1em; margin-top: 10px; background-color: #4CAF50; 
               color: white; border: none; border-radius: 5px; cursor: pointer;">
        {label}
        </button>
    """
    st.markdown(copy_code, unsafe_allow_html=True)







import base64
import tempfile
from fpdf import FPDF
from gtts import gTTS
import streamlit as st

# Extract assistant message
assistant_message = response["answer"]
sources = response.get("sources", "")
evaluation = response.get("evaluation", "")
full_text = f"R√©ponse:\n{assistant_message}\n\nSources:\n{sources}\n\n√âvaluation:\n{evaluation}"

# Save the assistant message
st.session_state.chat_sessions[st.session_state.current_chat].append({
    "role": "assistant",
    "content": assistant_message,
    "sources": sources,
    "evaluation": evaluation
})

# --- üí¨ Display the response ---
st.markdown(f"**Assistant:** {assistant_message}")

# --- üìã Real Copy-to-Clipboard Button ---
copy_button = f"""
    <button onclick="navigator.clipboard.writeText(`{assistant_message}`)"
    style="padding: 0.5em 1em; margin-top: 10px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
    üìã Copier la r√©ponse
    </button>
"""
st.markdown(copy_button, unsafe_allow_html=True)

# --- üìÑ Download as PDF ---
def generate_pdf(text):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in text.split('\n'):
        pdf.multi_cell(0, 10, line)
    tmp_file = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf")
    pdf.output(tmp_file.name)
    return tmp_file.name

pdf_path = generate_pdf(full_text)
with open(pdf_path, "rb") as f:
    st.download_button("üìÑ T√©l√©charger en PDF", f, file_name="reponse.pdf", mime="application/pdf")



import base64
import tempfile
from gtts import gTTS
from fpdf import FPDF
import streamlit as st

# Extract assistant message
assistant_message = response["answer"]
sources = response.get("sources", "")
evaluation = response.get("evaluation", "")
full_text = f"R√©ponse:\n{assistant_message}\n\nSources:\n{sources}\n\n√âvaluation:\n{evaluation}"

# Save the assistant message
st.session_state.chat_sessions[st.session_state.current_chat].append({
    "role": "assistant",
    "content": assistant_message,
    "sources": sources,
    "evaluation": evaluation
})

# Show the assistant response
st.markdown(f"**Assistant:** {assistant_message}")

# --- üìã Copy Button (using text area hack) ---
st.text_area("üìã Copier la r√©ponse", assistant_message, height=150)

# --- üì• Download PDF ---
def generate_pdf(text):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.set_font("Arial", size=12)
    for line in text.split('\n'):
        pdf.multi_cell(0, 10, line)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp_file:
        pdf.output(tmp_file.name)
        return tmp_file.name

pdf_path = generate_pdf(full_text)
with open(pdf_path, "rb") as f:
    st.download_button("üìÑ T√©l√©charger la r√©ponse en PDF", f, file_name="reponse.pdf", mime="application/pdf")

# --- üîä Voice Cover (French) ---
def play_tts(text, lang='fr'):
    tts = gTTS(text, lang=lang)
    with tempfile.NamedTemporaryFile(delete=False, suffix=".mp3") as fp:
        tts.save(fp.name)
        audio_file = fp.name
    st.audio(audio_file, format='audio/mp3')

play_tts(assistant_message)





def generate_response(prompt, context):
    try:
        completion = openai.ChatCompletion.create(
            engine="gpt-35-turbo",
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": context},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )
        return {"success": True, "answer": completion.choices[0].message.content}
    except Exception as e:
        return {"success": False, "answer": str(e)}




import streamlit as st
from PIL import Image
from datetime import datetime
import pandas as pd
import os
import pyttsx3

# Initialize TTS engine
engine = pyttsx3.init()
engine.setProperty('voice', 'french')  # Try setting a French voice if available
engine.setProperty('rate', 150)

# Dummy RAG chatbot response function (replace with your actual function)
def rag_chatbot(user_input):
    return {
        "answer": f"R√©ponse √† : {user_input}",
        "sources": ["Document 1", "Document 2"],
        "evaluation": "Pertinent"
    }

# Save feedback to CSV
def save_feedback(chat_id, message_index, feedback_type):
    feedback_file = "chat_feedback.csv"
    data = {
        "chat_id": chat_id,
        "message_index": message_index,
        "feedback": feedback_type,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    df = pd.DataFrame([data])
    if os.path.exists(feedback_file):
        df.to_csv(feedback_file, mode="a", header=False, index=False)
    else:
        df.to_csv(feedback_file, index=False)

# Play French response using TTS
def speak_text(text):
    engine.say(text)
    engine.runAndWait()

# Load logo
image = Image.open("/mnt/logo-banque.png")
st.image(image)

# Initialize session state
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}

if "current_chat" not in st.session_state:
    st.session_state.current_chat = None

# Sidebar: Chat session management
with st.sidebar:
    st.header("Chat Sessions")
    
    if st.button("+ New Chat"):
        chat_id = len(st.session_state.chat_sessions) + 1
        chat_name = f"Chat {chat_id}"
        st.session_state.chat_sessions[chat_name] = []
        st.session_state.current_chat = chat_name
    
    if st.session_state.chat_sessions:
        options = []
        for key, messages in st.session_state.chat_sessions.items():
            label = key
            for m in messages:
                if m["role"] == "user":
                    label = m["content"][:30] + "..." if len(m["content"]) > 30 else m["content"]
                    break
            options.append(f"{key}: {label}")
        
        selected = st.radio("Select Chat", options)
        selected_key = selected.split(":")[0]
        st.session_state.current_chat = selected_key

# Main chat interface
st.title("RAG Chatbot")

if st.session_state.current_chat:
    chat = st.session_state.chat_sessions[st.session_state.current_chat]

    # Display chat history
    for i, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"**[{message['timestamp']}]**")
            st.markdown(message["content"])

            if message["role"] == "assistant":
                with st.expander("Details"):
                    st.write("**Sources:**", message["sources"])
                    st.write("**Evaluation:**", message["evaluation"])

                # Feedback buttons
                col1, col2 = st.columns([1, 1])
                with col1:
                    if st.button("üëç", key=f"up_{i}"):
                        save_feedback(st.session_state.current_chat, i, "up")
                with col2:
                    if st.button("üëé", key=f"down_{i}"):
                        save_feedback(st.session_state.current_chat, i, "down")

# Input area
user_input = st.chat_input("Type your message here...")
if user_input and st.session_state.current_chat:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Add user message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    # Process response
    with st.spinner("Thinking..."):
        response = rag_chatbot(user_input)

    # Add assistant message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "assistant",
        "content": response["answer"],
        "sources": response["sources"],
        "evaluation": response["evaluation"]
    })

    # Speak the response aloud
    speak_text(response["answer"])

    st.rerun()


import streamlit as st
from PIL import Image
from datetime import datetime
import pandas as pd
import os
from gtts import gTTS
import base64

# Dummy RAG chatbot response function (replace with your actual function)
def rag_chatbot(user_input):
    return {
        "answer": f"R√©ponse √† : {user_input}",
        "sources": ["Document 1", "Document 2"],
        "evaluation": "Pertinent"
    }

# Generate French voice from text
def generate_audio(text, lang="fr"):
    tts = gTTS(text, lang=lang)
    tts.save("response.mp3")
    with open("response.mp3", "rb") as f:
        audio_bytes = f.read()
        b64 = base64.b64encode(audio_bytes).decode()
        return f'<audio controls autoplay><source src="data:audio/mp3;base64,{b64}" type="audio/mp3"></audio>'

# Save feedback to CSV
def save_feedback(chat_id, message_index, feedback_type):
    feedback_file = "chat_feedback.csv"
    data = {
        "chat_id": chat_id,
        "message_index": message_index,
        "feedback": feedback_type,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    df = pd.DataFrame([data])
    
    if os.path.exists(feedback_file):
        df.to_csv(feedback_file, mode="a", header=False, index=False)
    else:
        df.to_csv(feedback_file, index=False)

# Load logo
image = Image.open("/mnt/logo-banque.png")
st.image(image)

# Initialize session state
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}

if "current_chat" not in st.session_state:
    st.session_state.current_chat = None

# Sidebar: Chat session management
with st.sidebar:
    st.header("Chat Sessions")
    
    if st.button("+ New Chat"):
        chat_id = len(st.session_state.chat_sessions) + 1
        chat_name = f"Chat {chat_id}"
        st.session_state.chat_sessions[chat_name] = []
        st.session_state.current_chat = chat_name
    
    if st.session_state.chat_sessions:
        options = []
        for key, messages in st.session_state.chat_sessions.items():
            label = key
            for m in messages:
                if m["role"] == "user":
                    label = m["content"][:30] + "..." if len(m["content"]) > 30 else m["content"]
                    break
            options.append(f"{key}: {label}")
        
        selected = st.radio("Select Chat", options)
        selected_key = selected.split(":")[0]
        st.session_state.current_chat = selected_key

# Main chat interface
st.title("RAG Chatbot")

if st.session_state.current_chat:
    chat = st.session_state.chat_sessions[st.session_state.current_chat]

    # Display chat history
    for i, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"**[{message['timestamp']}]**")
            st.markdown(message["content"])

            if message["role"] == "assistant":
                if "timestamp" in message:
                    st.markdown(f"**[{message['timestamp']}]**")

                # Audio playback
                audio_html = generate_audio(message["content"])
                st.markdown(audio_html, unsafe_allow_html=True)

                with st.expander("Details"):
                    st.write("**Sources:**", message["sources"])
                    st.write("**Evaluation:**", message["evaluation"])
                
                # Rating thumbs
                col1, col2 = st.columns([1, 1])
                with col1:
                    if st.button("üëç", key=f"up_{i}"):
                        save_feedback(st.session_state.current_chat, i, "up")
                with col2:
                    if st.button("üëé", key=f"down_{i}"):
                        save_feedback(st.session_state.current_chat, i, "down")

# Input area
user_input = st.chat_input("Type your message here...")
if user_input and st.session_state.current_chat:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Add user message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    # Process response
    with st.spinner("Thinking..."):
        response = rag_chatbot(user_input)

    # Add assistant message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "assistant",
        "content": response["answer"],
        "sources": response["sources"],
        "evaluation": response["evaluation"],
        "timestamp": timestamp
    })

    st.rerun()





import streamlit as st
from PIL import Image
from datetime import datetime
import pandas as pd
import os

# Dummy RAG chatbot response function (replace with your actual function)
def rag_chatbot(user_input):
    return {
        "answer": f"Response to: {user_input}",
        "sources": ["Document 1", "Document 2"],
        "evaluation": "Relevant"
    }

# Load logo
image = Image.open("/mnt/logo-banque.png")
st.image(image)

# Initialize session state
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}

if "current_chat" not in st.session_state:
    st.session_state.current_chat = None

# Sidebar: Chat session management
with st.sidebar:
    st.header("Chat Sessions")
    
    if st.button("+ New Chat"):
        chat_id = len(st.session_state.chat_sessions) + 1
        chat_name = f"Chat {chat_id}"
        st.session_state.chat_sessions[chat_name] = []
        st.session_state.current_chat = chat_name
    
    if st.session_state.chat_sessions:
        options = []
        for key, messages in st.session_state.chat_sessions.items():
            label = key
            for m in messages:
                if m["role"] == "user":
                    label = m["content"][:30] + "..." if len(m["content"]) > 30 else m["content"]
                    break
            options.append(f"{key}: {label}")
        
        selected = st.radio("Select Chat", options)
        selected_key = selected.split(":")[0]
        st.session_state.current_chat = selected_key

# Main chat interface
st.title("RAG Chatbot")

if st.session_state.current_chat:
    chat = st.session_state.chat_sessions[st.session_state.current_chat]

    # Display chat history
    for i, message in enumerate(chat):
        with st.chat_message(message["role"]):
            if message["role"] == "user" and "timestamp" in message:
                st.markdown(f"**[{message['timestamp']}]**")
            st.markdown(message["content"])

            if message["role"] == "assistant":
                with st.expander("Details"):
                    st.write("**Sources:**", message["sources"])
                    st.write("**Evaluation:**", message["evaluation"])
                
                # Rating thumbs
                col1, col2 = st.columns([1, 1])
                with col1:
                    if st.button("üëç", key=f"up_{i}"):
                        save_feedback(st.session_state.current_chat, i, "up")
                with col2:
                    if st.button("üëé", key=f"down_{i}"):
                        save_feedback(st.session_state.current_chat, i, "down")

# Input area
user_input = st.chat_input("Type your message here...")
if user_input and st.session_state.current_chat:
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Add user message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "user",
        "content": user_input,
        "timestamp": timestamp
    })

    # Process response
    with st.spinner("Thinking..."):
        response = rag_chatbot(user_input)

    # Add assistant message
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "assistant",
        "content": response["answer"],
        "sources": response["sources"],
        "evaluation": response["evaluation"]
    })

    st.rerun()

# Save feedback to CSV
def save_feedback(chat_id, message_index, feedback_type):
    feedback_file = "chat_feedback.csv"
    data = {
        "chat_id": chat_id,
        "message_index": message_index,
        "feedback": feedback_type,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    df = pd.DataFrame([data])
    
    if os.path.exists(feedback_file):
        df.to_csv(feedback_file, mode="a", header=False, index=False)
    else:
        df.to_csv(feedback_file, index=False)






# --- Input area ---
user_input = st.chat_input("Type your message here...")

if user_input and st.session_state.current_chat:
    # Add user message to chat history
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "user",
        "content": user_input
    })

    # Process query with spinner
    with st.spinner("Thinking..."):
        response = rag_chatbot(user_input)  # Make sure `rag_chatbot()` is defined elsewhere

    # Add assistant response to chat history
    st.session_state.chat_sessions[st.session_state.current_chat].append({
        "role": "assistant",
        "content": response.get("answer", "No response."),
        "sources": response.get("sources", []),
        "evaluation": response.get("evaluation", "N/A")
    })

    # Rerun to update the chat display
    st.rerun()




import streamlit as st
from PIL import Image

# --- Initialize session state variables ---
if "chat_sessions" not in st.session_state:
    st.session_state.chat_sessions = {}

if "current_chat" not in st.session_state:
    st.session_state.current_chat = None

# --- Load and display logo ---
image = Image.open("/mnt/logo-banque.png")
st.image(image)

# --- Sidebar: Chat session controls ---
with st.sidebar:
    st.header("Chat Sessions")

    # Create new chat
    if st.button("+ New Chat"):
        new_chat_name = f"Chat {len(st.session_state.chat_sessions) + 1}"
        st.session_state.chat_sessions[new_chat_name] = []
        st.session_state.current_chat = new_chat_name

    # Display and select existing chats
    if st.session_state.chat_sessions:
        selected_chat = st.radio(
            "Select Chat",
            options=list(st.session_state.chat_sessions.keys()),
            index=0 if st.session_state.current_chat is None else list(st.session_state.chat_sessions.keys()).index(st.session_state.current_chat)
        )
        st.session_state.current_chat = selected_chat

# --- Main chat interface ---
st.title("RAG Chatbot")

# Display chat history
chat_container = st.container()

with chat_container:
    if st.session_state.current_chat:
        for message in st.session_state.chat_sessions[st.session_state.current_chat]:
            with st.chat_message(message["role"]):
                st.markdown(message["content"])

                if message["role"] == "assistant":
                    with st.expander("Details"):
                        st.write("**Sources:**", message.get("sources", "N/A"))
                        st.write("**Evaluation:**", message.get("evaluation", "N/A"))
    else:
        st.info("Please start a new chat or select an existing one.")


