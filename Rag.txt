import os
import json
import datetime

CHAT_HISTORY_FILE = "chat_history.json"

def handle_chat_history(user_input=None, response=None, clear=False):
    """
    Manages all chat history:
    - Initializes session state
    - Creates new sessions
    - Stores chat messages with timestamps
    - Saves to and loads from disk
    - Can clear all history
    """
    # === Load or initialize chat sessions
    if "chat_sessions" not in st.session_state:
        if os.path.exists(CHAT_HISTORY_FILE):
            with open(CHAT_HISTORY_FILE, "r", encoding="utf-8") as f:
                st.session_state.chat_sessions = json.load(f)
        else:
            st.session_state.chat_sessions = {}

    if clear:
        st.session_state.chat_sessions = {}
        st.session_state.current_chat = None
        if os.path.exists(CHAT_HISTORY_FILE):
            os.remove(CHAT_HISTORY_FILE)
        return

    # === Set up current chat session
    if "current_chat" not in st.session_state or st.session_state.current_chat is None:
        st.session_state.current_chat = str(datetime.datetime.now())

    # === Create session if it doesn't exist
    if st.session_state.current_chat not in st.session_state.chat_sessions:
        st.session_state.chat_sessions[st.session_state.current_chat] = {
            "title": "New Chat",
            "messages": []
        }

    session = st.session_state.chat_sessions[st.session_state.current_chat]

    # === Add user message
    if user_input:
        session["messages"].append({
            "role": "user",
            "content": user_input,
            "timestamp": datetime.datetime.now().isoformat()
        })

        # Set title if first user message
        if session["title"] == "New Chat":
            session["title"] = user_input[:30] + "..."

    # === Add assistant response
    if response:
        session["messages"].append({
            "role": "assistant",
            "content": response,
            "timestamp": datetime.datetime.now().isoformat()
        })

    # === Save sessions to disk
    with open(CHAT_HISTORY_FILE, "w", encoding="utf-8") as f:
        json.dump(st.session_state.chat_sessions, f, ensure_ascii=False, indent=2)



st.sidebar.title("üí¨ Chat History")

# Load session history
handle_chat_history()

# Sidebar session list
session_titles = {
    key: value["title"] for key, value in st.session_state.chat_sessions.items()
}

# Let user pick a session
if session_titles:
    selected_session = st.sidebar.radio("Select a chat", list(session_titles.keys()),
                                        format_func=lambda k: session_titles[k])
    st.session_state.current_chat = selected_session

# New chat button
if st.sidebar.button("‚ûï Start New Chat"):
    st.session_state.current_chat = str(datetime.datetime.now())

# Clear all
if st.sidebar.button("üóë Clear All Chats"):
    handle_chat_history(clear=True)
    st.experimental_rerun()









from fpdf import FPDF
import base64

def show_copy_and_download_buttons(answer_text: str):
    # === PDF creation
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in answer_text.split("\n"):
        pdf.multi_cell(0, 10, line)
    pdf_bytes = pdf.output(dest="S").encode("latin-1")

    # === PDF download button
    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )
import streamlit.components.v1 as components

def show_copy_button(text_to_copy: str):
    components.html(f"""
        <script>
        function copyText() {{
            const text = `{text_to_copy}`;
            navigator.clipboard.writeText(text).then(function() {{
                alert("‚úÖ Answer copied to clipboard!");
            }}, function(err) {{
                alert("‚ùå Failed to copy text: " + err);
            }});
        }}
        </script>
        <button onclick="copyText()" style="
            background-color: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 15px;
        ">üìã Copy Answer to Clipboard</button>
    """, height=50)



if user_input:
    handle_chat_history(user_input=user_input)

    with st.chat_message("assistant"):
        with st.spinner("Thinking..."):
            response = rag_chatbot(user_input, temp_chunks=temp_chunks)
            answer = response["answer"]

            st.markdown(answer, unsafe_allow_html=True)

            st.session_state["last_answer"] = answer  # üíæ Save for reuse
            handle_chat_history(response=answer)

# === Show Copy & Download Buttons if answer exists
if "last_answer" in st.session_state:
    show_copy_button(st.session_state["last_answer"])
    show_copy_and_download_buttons(st.session_state["last_answer"])










def show_copy_and_download_buttons(answer_text):
    # === Manual Copy Option
    with st.expander("üìã Copy Answer"):
        st.text_area("Copy the answer manually:", value=answer_text, height=200)

    # === PDF Download
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    for line in answer_text.split("\n"):
        pdf.multi_cell(0, 10, line)

    pdf_bytes = pdf.output(dest="S").encode("latin-1")  # Fresh bytes each time

    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )



def create_pdf_from_text(text):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    for line in text.split("\n"):
        pdf.multi_cell(0, 10, line)

    # Generate PDF as string
    pdf_output = pdf.output(dest='S').encode('latin-1')  # PDF raw bytes
    return pdf_output



def show_copy_and_download_buttons(answer_text):
    # Copy to clipboard (browser only)
    st.markdown(
        f"""
        <button onclick="navigator.clipboard.writeText(`{answer_text}`)"
        style="background-color:#4CAF50;color:white;padding:10px;border:none;border-radius:5px;margin-bottom:10px;">
        üìã Copy Answer to Clipboard
        </button>
        """,
        unsafe_allow_html=True,
    )

    # PDF download
    pdf_bytes = create_pdf_from_text(answer_text)
    st.download_button(
        label="üì• Download Answer as PDF",
        data=pdf_bytes,
        file_name="answer.pdf",
        mime="application/pdf"
    )



